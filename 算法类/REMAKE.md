## 算法类
* 排序
	* 快速排序: https://segmentfault.com/a/1190000009426421
	* 选择排序: https://segmentfault.com/a/1190000009366805
	* 希尔排序: https://segmentfault.com/a/1190000009461832
* 堆栈，队列，链表
	* 堆栈: https://juejin.im/entry/58759e79128fe1006b48cdfd
	* 队列: https://juejin.im/entry/58759e79128fe1006b48cdfd
	* 链表: https://juejin.im/entry/58759e79128fe1006b48cdfd
* 递归
	* 递归: https://segmentfault.com/a/1190000009857470
* 波兰式和逆波兰式
	* 理论: http://www.cnblogs.com/chenying99/p/3675876.html
	* 源码: https://github.com/Tairraos/rpn.js/blob/master/rpn.js

## 常见的排序算法
	* 常见的内部排序算法有：插入排序，希尔排序，选择排序，冒泡排序，归并排序，快速排序，堆排序，基数排序等

## 快速排序
	* 先从数列中取出一个数作为 基数
	* 分区过程： 将比这个 基准 大 的数全放到 基准 的右边，小于或等于 基准 的数全放到基准的左边	
	* 再对左右区间重复第二部，直到各区间只有一个数

## 选择排序
* 选择排序是一种简单直观的排序算法，无论什么数据进去都是O(n2)的时间复杂度。所以用到它的时候，数据
* 规模越小越好。唯一的好处可能就是不占用额外的内存空间了。通俗的来说就是你们中间谁最小谁就出列
* 站到队列的最后边，然后继续对着剩余的无序数组说你们中间谁最小谁出列，站到队列的最后边，一直到最后一个。
* 这样数组就有了顺序，从小到大	

## 选择排序的算法步骤
* 在未排序序列中找到最小(大)元素，存放到排序序列的起始位置。
* 从剩余未排序元素中继续寻找最小(大)元素，放到已排序序列的末尾
* 重复第二步，直到所有排序均排序完毕

## 希尔排序
* 希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。
* 希尔排序是基于插入排序的以下两点性质而提出改进方法的。
	* 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
	* 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。
* 希尔排序的基本思路是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待
* 整个序列中的记录 基本有序 时，再对全体记录进行依次直接插入排序	

## 希尔排序算法实现
* 选择一个增量序列 t1, t2, .... tk,其中ti > tj tk =1
* 按增量序列个数K，对序列进行k趟排序
* 每趟排序，根据对应的增量ti,将待排序列分割成若干长度为m的子序列，分别对各子表进行直接插入排序。
* 仅增量因子为1时，整个序列作为一个表来处理，表长度即为整个序列的长度。
