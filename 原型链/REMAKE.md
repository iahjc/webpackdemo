## 原型链  重点理解 必须搞懂
* 创建对象的几种方式
* 原型 构造函数 实例 原型链 是什么
* instanceof的原理
* new运算符的工作原理

## 创建对象的几种方式 需要自己写会 并且要练习说
		var o1 = {name: 'o1'}  字面量
		var o11 = new Object({name: 'o1'})

		var M = function() { 构造函数
			this.name = 'o2'
		}
		var o2 = new M()

		var P = { name: 'o3' }  object的create方法
		var o3 = Object.create(P)


## 原型 构造函数 实例 原型链 是什么
* 原型对象 即 prototype对象
* 构造函数
	* 构造函数可以通过new运算符生成一个实例
	* 构造函数也是函数
	* 函数都有一个prototype对象 prototype指向 原型对象 声明函数的时候系统自动加上去了
	* 只有构造函数和函数才有prototype对象 实例是没有的
	* 任何一个函数只要被new使用了就是构造函数
	* 原型对象中都有一个构造器constructor指向你声明的构造函数
	* 原型对象也是一个对象
	* 原型对象也是一个普通的对象 也有自己的__proto__ 这样就构成了原型链
	* 原型对象是被所有的实例所共享的
	* 函数即是函数，也是一个对象，所以函数也有__proto__
* 原型函数怎么区分被那个构造函数所引用
	* constructor属性 构造器
* __proto__
	* 实例的__proto__ 指向原型对象
	* 只有实例才有__proto__0

* 原型链
	* 我从一个实例往上找相关联的对象
	* 实例 	

## instanceof原理
* 判断实例对象是否是构造函数的实例
* instanceof判断的是是否是原型链上的构造函数 所以他也会判断Object构造函数  返回也为true
* 实例对象有一个__proto__ 指向构造函数的原型对象prototype
* 实例对象的constructor指向构造函数
* 构造函数的prototype指向原型

## new运算符的工作原理
* 一个新（空）对象被创建，他继承自构造函数的prototype
* 构造函数被执行，执行的时候，相应的参数会被传入，同时上下文(this)会被指定为这个新实例。
* new foo等同于new foo(),只能用在不传递任何参数的情况
* 如果构造函数返回一个 对象 ，那么这个对象会取代整个new出来的结果。如果构造函数没有返回对象，那么new出来的结果为步骤1创建的对象。	
